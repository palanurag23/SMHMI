# Smart Panel CM4

This Smart Panel CM4 slave project runs on the CM4 core.

It is linked into SDRAM and is embedded into the CM7 project.

The CM7 project handles the loading of this CM4 project into SDRAM and launching of it.

## Main functionalities
- Main GUI based on LVGL with Vglite graphics acceleration
- Camera with 2D PxP graphics acceleration
- Display for the camera preview and LVGL GUI
- USB shell
- LED indicator
- Multicore with messaging and shared memory communication

## LVGL GUI screens and widgets
All the LVGL GUI screens and widgets are generated with NXP's GUI Guider tools.

Refer to the [GUI Guider home page](https://www.nxp.com/design/software/development-software/gui-guider:GUI-GUIDER) for more information.

## LVGL and Vglite library
The LVGL and Vglite components are directly ported from RT1170 SDK and we did not modify them in our solution.

Also the code for the LVGL GUI screens and widgets, which are generated by NXP's GUI guider, is not frequently changed.

To speed up the building of the whole project, we moved these components into one static library and linked the library into the CM4 application project.

This LVGL and Vglite library project is located in the "home_panel/lvgl_vglite_lib" folder.

## Boot sequence
Below is the core boot up flow:

- Board level initialization
- Framework initialization
- HAL devices registration
- Framework startup
- FreeRTOS scheduler startup

The `main()` entry of this project is located in "home_panel/cm4/source/sln_smart_tlhmi_cm4.cpp" file:

```c
int main(void)
{
    /* init the board */
    APP_BoardInit();
    ...
    /* init the framework*/
    APP_InitFramework();

    /* register the hal devices*/
    APP_RegisterHalDevices();

    /* start the framework*/
    APP_StartFramework();

    vTaskStartScheduler();
    for (;;)
    {
    } /* should never get here */
    return 0;
}
```

## Board level initialization
The board level initialization is implemented in the `APP_BoardInit()` entry which is located in the "home_panel/cm4/source/sln_smart_tlhmi_cm4.cpp" file.

Below is the main flow:
- MPU, Clock, and Pins configuration
- Multicore manager init and slave startup
- Peripherals initialization

```c
void APP_BoardInit()
{
    BOARD_ConfigMPU();
    BOARD_BootClockRUN();
    BOARD_InitBootPins();

#if defined(ENABLE_SLAVE) && ENABLE_SLAVE
    uint32_t startupData, i;
    mcmgr_status_t status;
    (void)MCMGR_Init();
    /* Get the startup data */
    do
    {
        status = MCMGR_GetStartupData(&startupData);
    } while (status != kStatus_MCMGR_Success);
#endif /* defined(ENABLE_SLAVE) && ENABLE_SLAVE */
    ...
    BOARD_MIPIPanelTouch_I2C_Init();
    BOARD_InitEDMA();
    Time_Init(1);
}
```

## LVGL image resource and icon resource loading
All the LVGL images, data, and icon data are merged into one continuous binary block with the 64 Bytes aligned of each image/icon.

The cm7 loads this resource binary block into the dedicated memory region `res_sh_mem`.

The following two functions load each of these LVGL images and icons from this region during the boot.

Setup the LVGL images is implemented in "home_panel/cm4/custom/custom.c":
```c
void setup_imgs(unsigned char *base)
{
    _audio_player_background_1280x720.data      = (base + 0);
    _audio_player_mic_off_70x112.data           = (base + 1843200);
    _audio_player_next_140x214.data             = (base + 1858880);
    ....
}
```
Load the icons "framework/hal/output/hal_output_ui_home_panel.c":
```c
void LoadIcons(void *base)
{
    s_Icons[ICON_PROGRESS_BAR] = (base + 0);
}
```

## Framework managers
The below framework managers are enabled on the cm4 side with the following priorities:
- Low-power manager
- Camera manager - P2
- Display manager - P2
- Multicore manager - P0
- Output manager - P0
- Input manager - P2

Where P0 is the highest priority and P3 is the least prioritized.

For a more detailed description of these framework managers, refer to the framework chapter.

Framework initialization "home_panel/cm4/source/sln_smart_tlhmi_cm4.cpp"
```c
int APP_InitFramework(void)
{
    int ret = 0;

    FWK_MANAGER_INIT(LpmManager, ret);
    FWK_MANAGER_INIT(CameraManager, ret);
    FWK_MANAGER_INIT(DisplayManager, ret);
#if defined(ENABLE_SLAVE) && ENABLE_SLAVE
    FWK_MANAGER_INIT(MulticoreManager, ret);
#endif /* defined(ENABLE_SLAVE) && ENABLE_SLAVE */
    FWK_MANAGER_INIT(OutputManager, ret);
    FWK_MANAGER_INIT(InputManager, ret);

    return ret;
}
```

Framework startup "home_panel/cm4/source/sln_smart_tlhmi_cm4.cpp"
```c
int APP_StartFramework(void)
{
    int ret = 0;

    FWK_MANAGER_START(LpmManager, 0, ret);
    FWK_MANAGER_START(CameraManager, CAMERA_MANAGER_TASK_PRIORITY, ret);
    FWK_MANAGER_START(DisplayManager, DISPLAY_MANAGER_TASK_PRIORITY, ret);
#if defined(ENABLE_SLAVE) && ENABLE_SLAVE
    FWK_MANAGER_START(MulticoreManager, MULTICORE_MANAGER_TASK_PRIORITY, ret);
#endif /* defined(ENABLE_SLAVE) && ENABLE_SLAVE */
    FWK_MANAGER_START(OutputManager, OUTPUT_MANAGER_TASK_PRIORITY, ret);
    FWK_MANAGER_START(InputManager, INPUT_MANAGER_TASK_PRIORITY, ret);

    return ret;
}
```
## Framework HAL devices
The enabled HAL devices are configured in the "home_panel/cm4/board/board_define.h" file as shown below:
```c
#define ENABLE_GFX_DEV_Pxp
#define ENABLE_DISPLAY_DEV_LVGLHomePanel
#define ENABLE_CAMERA_DEV_MipiGc2145
#define ENABLE_OUTPUT_DEV_RgbLed
#if defined(ENABLE_SLAVE) && ENABLE_SLAVE
#define ENABLE_MULTICORE_DEV_MessageBuffer
#endif /* defined(ENABLE_SLAVE) && ENABLE_SLAVE */
#define ENABLE_INPUT_DEV_ShellUsb
#define ENABLE_OUTPUT_DEV_UiHomePanel
#define ENABLE_LPM_DEV_Standby
#define ENABLE_OUTPUT_DEV_IrWhiteLeds
```

The registration of the enabled HAL devices is implemented in the `APP_RegisterHalDevices(...)` function which is located in "home_panel/cm4/source/sln_smart_tlhmi_cm4.cpp":

```{note}
The `APP_RegisterHalDevices(...)` must be called after the framework initialization `APP_InitFramework(...)` and before framework startup `APP_StartFramework(...)`.
```

```c
int APP_RegisterHalDevices(void)
{
    int ret = 0;

    HAL_GFX_DEV_REGISTER(Pxp, ret);
    HAL_DISPLAY_DEV_REGISTER(LVGLHomePanel, ret);
    HAL_CAMERA_DEV_REGISTER(MipiGc2145, ret);
#if defined(ENABLE_SLAVE) && ENABLE_SLAVE
    HAL_MULTICORE_DEV_REGISTER(MessageBuffer, ret);
#endif /* defined(ENABLE_SLAVE) && ENABLE_SLAVE */
    HAL_OUTPUT_DEV_REGISTER(RgbLed, ret);
    HAL_INPUT_DEV_REGISTER(ShellUsb, ret);
    HAL_OUTPUT_DEV_REGISTER(UiHomePanel, ret);
    HAL_LPM_DEV_REGISTER(Standby, ret);
    HAL_OUTPUT_DEV_REGISTER(IrWhiteLeds, ret);
#ifdef ENABLE_OUTPUT_DEV_AudioDump
    HAL_OUTPUT_DEV_REGISTER(AudioDump, ret);
#endif /* ENABLE_OUTPUT_DEV_AudioDump */
    /* Add new HAL device registrations here */

    return ret;
}
```

### MipiGc2145 camera HAL device
This HAL device driver is located in "framework/hal/camera/hal_camera_mipi_gc2145.c".

Below is the configuration of this camera device located in "home_panel/cm4/board/board_define.h".

```c
#ifdef ENABLE_CAMERA_DEV_MipiGc2145
#define CAMERA_DEV_MipiGc2145_BUFFER_COUNT 2
#define CAMERA_DEV_MipiGc2145_HEIGHT       600 // 720
#define CAMERA_DEV_MipiGc2145_WIDTH        800 // 1280
#define CAMERA_DEV_MipiGc2145_LEFT         0
#define CAMERA_DEV_MipiGc2145_TOP          0
#define CAMERA_DEV_MipiGc2145_RIGHT        799 // 1279
#define CAMERA_DEV_MipiGc2145_BOTTOM       599 // 719
#define CAMERA_DEV_MipiGc2145_ROTATE       kCWRotateDegree_0
#define CAMERA_DEV_MipiGc2145_FLIP         kFlipMode_None
#define CAMERA_DEV_MipiGc2145_SWAPBYTE     0
#define CAMERA_DEV_MipiGc2145_FORMAT       kPixelFormat_YUV1P444_RGB
#define CAMERA_DEV_MipiGc2145_BPP          4
#endif /* ENABLE_CAMERA_DEV_MipiGc2145 */
```

### PxP graphics HAL device
This HAL device driver is located in "framework/hal/misc/hal_graphics_pxp.c".

It represents the 2D graphics device to handle the 2D graphics operations.

### LVGLHomePanel display HAL device
This HAL device driver is located in "framework/hal/display/hal_display_lvgl_homepanel.c".

Below is the configuration of this display device located in "home_panel/cm4/board/board_define.h".

```c
#ifdef ENABLE_DISPLAY_DEV_LVGLHomePanel
#define DISPLAY_DEV_LVGLHomePanel_BUFFER_COUNT 1
#define DISPLAY_DEV_LVGLHomePanel_HEIGHT       640
#define DISPLAY_DEV_LVGLHomePanel_WIDTH        480
#define DISPLAY_DEV_LVGLHomePanel_StartX       110
#define DISPLAY_DEV_LVGLHomePanel_StartY       30
#define DISPLAY_DEV_LVGLHomePanel_LEFT         0
#define DISPLAY_DEV_LVGLHomePanel_TOP          0
#define DISPLAY_DEV_LVGLHomePanel_RIGHT        479
#define DISPLAY_DEV_LVGLHomePanel_BOTTOM       639
#define DISPLAY_DEV_LVGLHomePanel_ROTATE       kCWRotateDegree_270
#define DISPLAY_DEV_LVGLHomePanel_FORMAT       kPixelFormat_RGB565
#ifdef ENABLE_CAMERA_DEV_MipiGc2145
#define DISPLAY_DEV_LVGLHomePanel_SRCFORMAT kPixelFormat_YUV1P444_RGB
#else
#define DISPLAY_DEV_LVGLHomePanel_SRCFORMAT kPixelFormat_UYVY1P422_RGB
#endif /* ENABLE_CAMERA_DEV_MipiGc2145 */
#define DISPLAY_DEV_LVGLHomePanel_BPP 2
#endif /* ENABLE_DisplayDev_LVGLHomePanel */
```

This LVGLHomePanel-display-HAL-device launches the main LVGL task loop for the UI flashing.

```c
static void _LvglTask(void *param)
{
#if LV_USE_LOG
    lv_log_register_print_cb(_PrintCb);
#endif /* LV_USE_LOG */

    lv_port_pre_init();
    lv_init();
    lv_port_disp_init();
    lv_port_indev_init();
    g_LvglInitialized = true;

    setup_imgs((unsigned char *)APP_LVGL_IMGS_BASE);
    setup_ui(&guider_ui);
    events_init(&guider_ui);
    custom_init(&guider_ui);
    while (1)
    {
        LVGL_LOCK();
        lv_task_handler();
        LVGL_UNLOCK();
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}
```

It also handles the camera preview request from the framework in `HAL_DisplayDev_LVGLHomePanel_Blit` function:

```c
hal_display_status_t HAL_DisplayDev_LVGLHomePanel_Blit(const display_dev_t *dev, void *frame, int width, int height)
{
    hal_display_status_t ret = kStatus_HAL_DisplaySuccess;
    LOGI("++HAL_DisplayDev_LVGLHomePanel_Blit");

    // Show the new frame.
    void *lcdFrameAddr             = s_LcdBuffer[0];
    static int camerPreviewLayerOn = 0;

    // enable camera preview layer in screen with camera preview.
    if (s_EnableCameraPreview && (g_PreviewMode == PREVIEW_MODE_CAMERA))
    {
        if (camerPreviewLayerOn == 0)
        {
            lv_enable_camera_preview(lcdFrameAddr, true);
            camerPreviewLayerOn = 1;
        }
    }
    else
    {
        // disable camera preview layer in screen without camera preview.
        if (camerPreviewLayerOn == 1)
        {
            camerPreviewLayerOn = 0;
            lv_enable_camera_preview(lcdFrameAddr, false);
        }
    }

    if (camerPreviewLayerOn)
    {
        ret = kStatus_HAL_DisplayRequestFrame;
    }

    LOGI("--HAL_DisplayDev_LVGLHomePanel_Blit");
    return ret;
}
```

### UiHomePanel UI output HAL device
This HAL device driver is located in "framework/hal/output/hal_output_ui_home_panel.c".

The whole UI state machine is driven by this output HAL device with the below event sources:

 #### LVGL touch events

 All the event callbacks of the LVGL widget are implemented in "home_panel/cm4/generated/events_init.c".

 #### Vision and Voice algorithm inference result
 The vision (face and gesture) and voice inference result is notified by the output manager with below `HAL_OutputDev_UiHomePanel_InferComplete` operator:

```c
static hal_output_status_t HAL_OutputDev_UiHomePanel_InferComplete(const output_dev_t *dev,
                                                                   output_algo_source_t source,
                                                                   void *inferResult)
{
    hal_output_status_t error = kStatus_HAL_OutputSuccess;

    if (inferResult == NULL)
    {
        return error;
    }

#if AQT_TEST
    if(source == kOutputAlgoSource_Voice)
    {
        _control_audio_player(inferResult);
    }
#endif /* AQT_TEST */

    LVGL_LOCK();
    home_panel_screen_id_t currentScreenId = get_current_screen();

    if (currentScreenId == kScreen_Num)
    {
        LVGL_UNLOCK();
        return error;
    }

    if (source == kOutputAlgoSource_Vision)
    {
        _InferComplete_Vision(dev, inferResult, currentScreenId);
    }

    else if (source == kOutputAlgoSource_Voice)
    {
        _InferComplete_Voice(dev, inferResult, currentScreenId);
    }
    LVGL_UNLOCK();
    return error;
}
```

### RgbLed output HAL device
This HAL device driver is located in "framework/hal/output/hal_output_rgb_led.c".

It flashes the RGB led with different pattern according to the `HAL_OutputDev_RgbLed_InferComplete` or `HAL_OutputDev_RgbLed_InputNotify` operators below:

```c
static hal_output_status_t HAL_OutputDev_RgbLed_InferComplete(const output_dev_t *dev, output_algo_source_t source, void *inferResult)
{
    hal_output_status_t error = kStatus_HAL_OutputSuccess;
    uint32_t timerOn          = 0;
    _SetLedColor(APP_OutputDev_RgbLed_InferCompleteDecode(source, inferResult, &timerOn));

    if (timerOn != 0)
    {
        xTimerChangePeriod(OutputRgbTimer, pdMS_TO_TICKS(timerOn), 0);
    }
    return error;
}
```

```c
static hal_output_status_t HAL_OutputDev_RgbLed_InputNotify(const output_dev_t *dev, void *data)
{
    hal_output_status_t error = kStatus_HAL_OutputSuccess;

    _SetLedColor(APP_OutputDev_RgbLed_InputNotifyDecode(data));

    return error;
}
```

### MessageBuffer multicore HAL device
This HAL device driver is located in "framework/hal/misc/hal_multicore_messageBuffer.c".

It handles the multicore messaging based on the multicore manager message buffer mechanism.

Refer the "framework-> HAL_devices -> Multicore devices" part in the framework chapter for the detailed description of this HAL device.

### ShellUsb input HAL device
This HAL device driver is located in "framework/hal/input/hal_input_shell_cdc.c".

It populates one USB CDC ACM device and implements a shell command interface.

This driver only includes one `weak` shell command registration function as below:

```c
__attribute__((weak)) void APP_InputDev_Shell_RegisterShellCommands(shell_handle_t shellContextHandle,  input_dev_t shellDev, input_dev_callback_t callback)
{
}
```

The application should overwrite this function to register the application specific shell commands.

The implementation of this overwritten function for the `Smart Panel` application is in "home_panel/cm4/source/event_handler/smart_tlhmi_input_shell_commands.c":

```c
void APP_InputDev_Shell_RegisterShellCommands(shell_handle_t shellContextHandle, input_dev_t *shellDev, input_dev_callback_t callback)
{
    s_InputCallback            = callback;
    s_SourceShell              = shellDev;
    s_ShellHandle              = shellContextHandle;
    s_FrameworkRequest.respond = _FrameworkEventsHandler;

    if (s_ThingName == NULL)
    {
        APP_GetHexUniqueID(&s_ThingName);
    }

    SHELL_RegisterCommand(shellContextHandle, SHELL_COMMAND(version));
    ...
}
```

### Standby LPM HAL device
This HAL device driver is located in "framework/hal/misc/hal_lpm_standby.c".

Refer to "framework -> HAL Devices/docs/hal_devices/low_power.md" in the framework documentation for the detailed description of this LPM device.

This standby HAL device implements the standby mode of this application. The backlight is turned off and the main display layer is disabled.

```c
static void _EnterStandbyMode(void)
{
    LOGD("[Standby] Enter standby mode");
    BOARD_BacklightControl(0);
    lv_enable_ui_preview(0);
}
```

## Logging
Both the CM7 and CM4 projects are leveraging the [FreeRTOS logging library](https://www.freertos.org/logging.html).

The FreeRTOS logging library code is located in the logging folder where you can find the detailed document "home_panel/cm4/freertos/libraries/logging/README.md".

The CM7 and CM4 share low-level LPUART12 peripheral for the logging output. The hardware semaphore mechanism is used to guarantee the concurrence access of the LPUART12 peripheral.

They share a low-level timer to get the unified timestamp of the logging information.

### Logging Task Init
Application calls `xLoggingTaskInitialize(...)` API to create the logging task in the `main()` entry of this project is located in the "coffee_machine/cm4/source/sln_smart_tlhmi_cm4.cpp" file:

```c
xLoggingTaskInitialize(LOGGING_TASK_STACK_SIZE, LOGGING_TASK_PRIORITY, LOGGING_QUEUE_LENGTH);
```

### Logging Macros
The logging Macros are defined in "framework/inc/fwk_log.h".

All the modules must use these unified logging Macros for logging.

```c
#ifndef LOGV
#define LOGV(fmt, args...) {implement...}
...
#endif

#ifndef LOGD
#define LOGD(fmt, args...) {implement...}
#endif

#ifndef LOGI
#define LOGI(fmt, args...) {implement...}
#endif

#ifndef LOGE
#define LOGE(fmt, args...) {implement...}
#endif
```
### UART Hardware Connection
The Smart Panel application prints the log to the LPUART12 port. The tx/rx pins of LPUART12 are connected to J202, at the back of the board (pin3-RX and pin4-TX).
Connect the LPUART12 tx/rx pins to a TTL USB serial adapter (LPUART12 rx pin to usb adapter tx pin, LPUART12 tx pin to usb adapter rx pin), and connect the TTL USB serial adapter.

### Get UART log from Windows Host
For a Windows host system, find the corresponding COM port number from the Windows "Device Manager" for the newly connected TTL USB serial adapter. Using terminal emulator program (f.e putty) to connect to the COM port, setting the speed to 115200Hz.

### Get UART log from Linux Host
For a Linux host system, Connect to the serial port (usually /dev/ttyUSBx) using a Linux terminal emulator program (f.e minicom), use 115200 8N1 as the serial port setting for the serial communication.
