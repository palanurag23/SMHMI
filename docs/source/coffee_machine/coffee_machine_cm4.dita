<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE dita PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<dita>
    <topic id="coffee-machine-cm4">
        <title>Coffee machine CM4</title>
        <prolog>
            <data name="sidebar_position" value="3"/>
        </prolog>
        <body>
            <p>This Coffee Machine CM4 slave project is running on the CM4 core.</p>
            <p>It is linked into SDRAM and is embedded into the CM7 project.</p>
            <p>The CM7 project handles the loading of this CM4 project into SDRAM and launching of
                it.</p>
        </body>
    </topic>
    <topic id="main-functionalities">
        <title>Main functionalities</title>
        <prolog>
            <data name="sidebar_position" value="3"/>
        </prolog>
        <body>
            <ul>
                <li><p>Main GUI based on LVGL with Vglite graphics acceleration</p></li>
                <li><p>Camera with 2D PxP graphics acceleration</p></li>
                <li><p>Display for the camera preview and LVGL GUI</p></li>
                <li><p>USB shell</p></li>
                <li><p>LED indicator</p></li>
                <li><p>Multicore with messaging and shared memory communication</p></li>
            </ul>
        </body>
    </topic>
    <topic id="lvgl-gui-screens-and-widgets">
        <title>LVGL GUI screens and widgets</title>
        <prolog>
            <data name="sidebar_position" value="3"/>
        </prolog>
        <body>
            <p>All the LVGL GUI screens and widgets are generated with NXP's GUI Guider tools.</p>
            <p>Refer the <xref
                    href="https://www.nxp.com/design/software/development-software/gui-guider:GUI-GUIDER"
                    format="html" scope="external">GUI Guider home page</xref> for more
                information.</p>
        </body>
    </topic>
    <topic id="lvgl-and-vglite-library">
        <title>LVGL and Vglite library</title>
        <prolog>
            <data name="sidebar_position" value="3"/>
        </prolog>
        <body>
            <p>The LVGL and Vglite components are directly ported from RT1170 SDK and we did not
                modify them in our solution.</p>
            <p>Also the code for the LVGL GUI screens and widgets, which are generated by NXP's GUI
                guider, is not frequently changed.</p>
            <p>To speed up the building of the whole project, we moved these components into one
                static library and linked the library into the CM4 application project.</p>
            <p>This LVGL and Vglite library project is located in the
                "coffee_machine/lvgl_vglite_lib" folder.</p>
        </body>
    </topic>
    <topic id="boot-sequence">
        <title>Boot sequence</title>
        <prolog>
            <data name="sidebar_position" value="3"/>
        </prolog>
        <body>
            <p>Below is the core boot up flow:</p>
            <ul>
                <li><p>Board level initialization</p></li>
                <li><p>Framework initialization</p></li>
                <li><p>HAL devices registration</p></li>
                <li><p>Framework startup</p></li>
                <li><p>FreeRTOS scheduler startup</p></li>
            </ul>
            <p>The <codeph>main()</codeph> entry of this project is located in
                "coffee_machine/cm4/source/sln_smart_tlhmi_cm4.cpp" file:</p>
            <codeblock xml:space="preserve" outputclass="c">int main(void)
{
    /* init the board */
    APP_BoardInit();
    ...
    /* init the framework*/
    APP_InitFramework();

    /* register the hal devices*/
    APP_RegisterHalDevices();

    /* start the framework*/
    APP_StartFramework();

    vTaskStartScheduler();
    for (;;)
    {
    } /* should never get here */
    return 0;
}</codeblock>
        </body>
    </topic>
    <topic id="board-level-initialization">
        <title>Board level initialization</title>
        <prolog>
            <data name="sidebar_position" value="3"/>
        </prolog>
        <body>
            <p>The board level initialization is implemented in the <codeph>APP_BoardInit()</codeph>
                entry which is located in the "coffee_machine/cm4/source/sln_smart_tlhmi_cm4.cpp"
                file.</p>
            <p>Below is the main flow:</p>
            <ul>
                <li><p>MPU, Clock, and Pins configuration</p></li>
                <li><p>Multicore manager init and slave startup</p></li>
                <li><p>Peripherals initialization</p></li>
            </ul>
            <codeblock xml:space="preserve" outputclass="c">void APP_BoardInit()
{
    BOARD_ConfigMPU();
    BOARD_BootClockRUN();
    BOARD_InitBootPins();

#if defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE
    uint32_t startupData, i;
    mcmgr_status_t status;
    (void)MCMGR_Init();
    /* Get the startup data */
    do
    {
        status = MCMGR_GetStartupData(&amp;startupData);
    } while (status != kStatus_MCMGR_Success);
#endif /* defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE */
    ...
    BOARD_MIPIPanelTouch_I2C_Init();
    BOARD_InitEDMA();
    Time_Init(1);
}</codeblock>
        </body>
    </topic>
    <topic id="lvgl-image-resource-and-icon-resource-loading">
        <title>LVGL image resource and icon resource loading</title>
        <prolog>
            <data name="sidebar_position" value="3"/>
        </prolog>
        <body>
            <p>All the LVGL images, data, and icon data are merged into one continuous binary block
                with the 64 Bytes aligned of each image/icon.</p>
            <p>The cm7 loads this resource binary block into the dedicated memory region
                    <codeph>res_sh_mem</codeph>.</p>
            <p>The following two functions load each of these LVGL images and icons from this region
                during the boot.</p>
            <p>Setup the LVGL images is implemented in
                "coffee_machine/cm4/generated/gui_guider.c":</p>
            <codeblock xml:space="preserve" outputclass="c">void setup_imgs(unsigned char *base)
{
    brewing_animimg_brewingf01.data = (base + 0);
    brewing_animimg_brewingf02.data = (base + 120000);
    brewing_animimg_brewingf03.data = (base + 240000);
    ....
}</codeblock>
            <p>Load the icons "framework/hal/output/hal_output_ui_coffee_machine.c":</p>
            <codeblock xml:space="preserve" outputclass="c">void LoadIcons(void *base)
{
    s_Icons[ICON_PROGRESS_BAR] = (base + 0);

    s_Icons[ICON_VIRTUAL_FACE_BLUE]  = (base + 6720);
    s_Icons[ICON_VIRTUAL_FACE_GREEN] = (base + 364608);
    s_Icons[ICON_VIRTUAL_FACE_RED]   = (base + 722496);
    // Icons Total: 0x00107c40  1080384
}</codeblock>
        </body>
    </topic>
    <topic id="framework-managers">
        <title>Framework managers</title>
        <prolog>
            <data name="sidebar_position" value="3"/>
        </prolog>
        <body>
            <p>The below framework managers are enabled on the cm4 side with the following
                priorities:</p>
            <ul>
                <li><p>Low-power manager</p></li>
                <li><p>Camera manager - P2</p></li>
                <li><p>Display manager - P2</p></li>
                <li><p>Multicore manager - P0</p></li>
                <li><p>Output manager - P1</p></li>
                <li><p>Input manager - P2</p></li>
            </ul>
            <p>Where P0 is the highest priority and P3 is the least prioritized.</p>
            <p>For a more detailed description of these framework managers, refer to the framework
                documentation "framework/doc".</p>
            <p>Framework initialization "coffee_machine/cm4/source/sln_smart_tlhmi_cm4.cpp"</p>
            <codeblock xml:space="preserve" outputclass="c">int APP_InitFramework(void)
{
    int ret = 0;

    FWK_MANAGER_INIT(LpmManager, ret);
    FWK_MANAGER_INIT(CameraManager, ret);
    FWK_MANAGER_INIT(DisplayManager, ret);
#if defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE
    FWK_MANAGER_INIT(MulticoreManager, ret);
#endif /* defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE */
    FWK_MANAGER_INIT(OutputManager, ret);
    FWK_MANAGER_INIT(InputManager, ret);

    return ret;
}</codeblock>
            <p>Framework startup "coffee_machine/cm4/source/sln_smart_tlhmi_cm4.cpp"</p>
            <codeblock xml:space="preserve" outputclass="c">int APP_StartFramework(void)
{
    int ret = 0;

    FWK_MANAGER_START(LpmManager, 0, ret);
    FWK_MANAGER_START(CameraManager, CAMERA_MANAGER_TASK_PRIORITY, ret);
    FWK_MANAGER_START(DisplayManager, DISPLAY_MANAGER_TASK_PRIORITY, ret);
#if defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE
    FWK_MANAGER_START(MulticoreManager, MULTICORE_MANAGER_TASK_PRIORITY, ret);
#endif /* defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE */
    FWK_MANAGER_START(OutputManager, OUTPUT_MANAGER_TASK_PRIORITY, ret);
    FWK_MANAGER_START(InputManager, INPUT_MANAGER_TASK_PRIORITY, ret);

    return ret;
}</codeblock>
        </body>
    </topic>
    <topic id="framework-hal-devices">
        <title>Framework HAL devices</title>
        <prolog>
            <data name="sidebar_position" value="3"/>
        </prolog>
        <body>
            <p>The enabled HAL devices are configured in the
                "coffee_machine/cm4/board/board_define.h" file as shown below:</p>
            <codeblock xml:space="preserve" outputclass="c">#define ENABLE_GFX_DEV_Pxp
#define ENABLE_DISPLAY_DEV_LVGLCoffeeMachine
#define ENABLE_CAMERA_DEV_MipiGc2145
#define ENABLE_OUTPUT_DEV_RgbLed
#if defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE
#define ENABLE_MULTICORE_DEV_MessageBuffer
#endif /* defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE */
#define ENABLE_INPUT_DEV_ShellUsb
#define ENABLE_OUTPUT_DEV_UiCoffeeMachine
#define ENABLE_LPM_DEV_Standby</codeblock>
            <p>The registration of the enabled HAL devices is implemented in the
                    <codeph>APP_RegisterHalDevices(...)</codeph> function which is located in
                "coffee_machine/cm4/source/sln_smart_tlhmi_cm4.cpp":</p>
            <codeblock xml:space="preserve">The `APP_RegisterHalDevices(...)` must be called after the framework initialization `APP_InitFramework(...)` and before framework startup `APP_StartFramework(...)`.</codeblock>
            <codeblock xml:space="preserve" outputclass="c">int APP_RegisterHalDevices(void)
{
    int ret = 0;

    HAL_GFX_DEV_REGISTER(Pxp, ret);
    HAL_DISPLAY_DEV_REGISTER(LVGLCoffeeMachine, ret);
    HAL_CAMERA_DEV_REGISTER(MipiGc2145, ret);
#if defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE
    HAL_MULTICORE_DEV_REGISTER(MessageBuffer, ret);
#endif /* defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE */
    HAL_OUTPUT_DEV_REGISTER(RgbLed, ret);
    HAL_INPUT_DEV_REGISTER(ShellUsb, ret);
    HAL_OUTPUT_DEV_REGISTER(UiCoffeeMachine, ret);
    HAL_LPM_DEV_REGISTER(Standby, ret);
#ifdef ENABLE_OUTPUT_DEV_AudioDump
    HAL_OUTPUT_DEV_REGISTER(AudioDump, ret);
#endif /* ENABLE_OUTPUT_DEV_AudioDump */
    /* Add new HAL device registrations here */

    return ret;
}</codeblock>
        </body>
        <topic id="mipigc2145-camera-hal-device">
            <title>MipiGc2145 camera HAL device</title>
            <body>
                <p>This HAL device driver is located in
                    "framework/hal/camera/hal_camera_mipi_gc2145.c".</p>
                <p>Below is the configuration of this camera device located in
                    "coffee_machine/cm4/board/board_define.h".</p>
                <codeblock xml:space="preserve" outputclass="c">#ifdef ENABLE_CAMERA_DEV_MipiGc2145
#define CAMERA_DEV_MipiGc2145_BUFFER_COUNT 2
#define CAMERA_DEV_MipiGc2145_HEIGHT       600 // 720
#define CAMERA_DEV_MipiGc2145_WIDTH        800 // 1280
#define CAMERA_DEV_MipiGc2145_LEFT         0
#define CAMERA_DEV_MipiGc2145_TOP          0
#define CAMERA_DEV_MipiGc2145_RIGHT        799 // 1279
#define CAMERA_DEV_MipiGc2145_BOTTOM       599 // 719
#define CAMERA_DEV_MipiGc2145_ROTATE       kCWRotateDegree_0
#define CAMERA_DEV_MipiGc2145_FLIP         kFlipMode_None
#define CAMERA_DEV_MipiGc2145_SWAPBYTE     0
#define CAMERA_DEV_MipiGc2145_FORMAT       kPixelFormat_YUV1P444_RGB
#define CAMERA_DEV_MipiGc2145_BPP          4
#endif /* ENABLE_CAMERA_DEV_MipiGc2145 */</codeblock>
            </body>
        </topic>
        <topic id="pxp-graphics-hal-device">
            <title>PxP graphics HAL device</title>
            <body>
                <p>This HAL device driver is located in "framework/hal/misc/hal_graphics_pxp.c".</p>
                <p>It represents the 2D graphics device to handle the 2D graphics operations.</p>
            </body>
        </topic>
        <topic id="lvglcoffeemachine-display-hal-device">
            <title>LVGLCoffeeMachine display HAL device</title>
            <body>
                <p>This HAL device driver is located in
                    "framework/hal/display/hal_display_lvgl_coffeemachine.c".</p>
                <p>Below is the configuration of this display device located in
                    "coffee_machine/cm4/board/board_define.h".</p>
                <codeblock xml:space="preserve" outputclass="c">#ifdef ENABLE_DISPLAY_DEV_LVGLCoffeeMachine
#define DISPLAY_DEV_LVGLCoffeeMachine_BUFFER_COUNT 1
#define DISPLAY_DEV_LVGLCoffeeMachine_HEIGHT       640
#define DISPLAY_DEV_LVGLCoffeeMachine_WIDTH        480
#define DISPLAY_DEV_LVGLCoffeeMachine_StartX       80
#define DISPLAY_DEV_LVGLCoffeeMachine_StartY       50
#define DISPLAY_DEV_LVGLCoffeeMachine_LEFT         0
#define DISPLAY_DEV_LVGLCoffeeMachine_TOP          0
#define DISPLAY_DEV_LVGLCoffeeMachine_RIGHT        479
#define DISPLAY_DEV_LVGLCoffeeMachine_BOTTOM       639
#define DISPLAY_DEV_LVGLCoffeeMachine_ROTATE       kCWRotateDegree_270
#define DISPLAY_DEV_LVGLCoffeeMachine_FORMAT       kPixelFormat_RGB565
#ifdef ENABLE_CAMERA_DEV_MipiGc2145
#define DISPLAY_DEV_LVGLCoffeeMachine_SRCFORMAT kPixelFormat_YUV1P444_RGB
#else
#define DISPLAY_DEV_LVGLCoffeeMachine_SRCFORMAT kPixelFormat_UYVY1P422_RGB
#endif /* ENABLE_CAMERA_DEV_MipiGc2145 */
#define DISPLAY_DEV_LVGLCoffeeMachine_BPP 2
#endif /* ENABLE_DisplayDev_LVGLCoffeeMachine */</codeblock>
                <p>This LVGLCoffeeMachine-display-HAL-device launches the main LVGL task loop for
                    the UI flashing.</p>
                <codeblock xml:space="preserve" outputclass="c">static void _LvglTask(void *param)
{
#if LV_USE_LOG
    lv_log_register_print_cb(_PrintCb);
#endif /* LV_USE_LOG */

    lv_port_pre_init();
    lv_init();
    lv_port_disp_init();
    lv_port_indev_init();
    g_LvglInitialized = true;

    setup_imgs((unsigned char *)APP_LVGL_IMGS_BASE);
    setup_ui(&amp;guider_ui);
    events_init(&amp;guider_ui);
    custom_init(&amp;guider_ui);
    while (1)
    {
        lv_task_handler();
        vTaskDelay(pdMS_TO_TICKS(5));
    }
}</codeblock>
                <p>It also handles the camera preview request from the framework in
                        <codeph>HAL_DisplayDev_LVGLCoffeeMachine_Blit</codeph> function:</p>
                <codeblock xml:space="preserve" outputclass="c">hal_display_status_t HAL_DisplayDev_LVGLCoffeeMachine_Blit(const display_dev_t *dev, void *frame, int width, int height)
{
    hal_display_status_t ret = kStatus_HAL_DisplaySuccess;
    LOGI("++HAL_DisplayDev_LVGLCoffeeMachine_Blit");

    // Show the new frame.
    void *lcdFrameAddr             = s_LcdBuffer[0];
    static int camerPreviewLayerOn = 0;

    // enable camera preview layer in screen with camera preview.
    if (lv_scr_act() == guider_ui.home &amp;&amp; g_PreviewMode == PREVIEW_MODE_CAMERA)
    {
        if (camerPreviewLayerOn == 0)
        {
            lv_enable_camera_preview(lcdFrameAddr, true);
            camerPreviewLayerOn = 1;
        }
    }
    else
    {
        // disable camera preview layer in screen without camera preview.
        if (camerPreviewLayerOn == 1)
        {
            camerPreviewLayerOn = 0;
            lv_enable_camera_preview(lcdFrameAddr, false);
        }
    }

    LOGI("--HAL_DisplayDev_LVGLCoffeeMachine_Blit");
    return ret;
}</codeblock>
            </body>
        </topic>
        <topic id="uicoffeemachine-ui-output-hal-device">
            <title>UiCoffeeMachine UI output HAL device</title>
            <body>
                <p>This HAL device driver is located in
                    "framework/hal/output/hal_output_ui_coffee_machine.c".</p>
                <p>The whole UI state machine is driven by this output HAL device with the below
                    event sources:</p>
            </body>
            <topic id="lvgl-touch-events">
                <title>LVGL touch events</title>
                <body>
                    <p>All the event callbacks of the LVGL widget are implemented in
                        "coffee_machine/cm4/generated/events_init.c".</p>
                </body>
            </topic>
            <topic id="vision-and-voice-algorithm-inference-result">
                <title>Vision and Voice algorithm inference result</title>
                <body>
                    <p>The vision and voice inference result is notified by the output manager with
                        below <codeph>HAL_OutputDev_UiCoffeeMachine_InferComplete</codeph>
                        operator:</p>
                    <codeblock xml:space="preserve" outputclass="c">static hal_output_status_t HAL_OutputDev_UiCoffeeMachine_InferComplete(const output_dev_t *dev,output_algo_source_t source,void *inferResult)
{
    hal_output_status_t error = kStatus_HAL_OutputSuccess;

    if (inferResult == NULL)
    {
        return error;
    }

    coffee_machine_screen_id_t currentScreenId = get_current_screen();

    if (currentScreenId == SCR_INVALID)
    {
        return error;
    }

    if (source == kOutputAlgoSource_Vision)
    {
        _InferComplete_Vision(dev, inferResult, currentScreenId);
    }
    else if (source == kOutputAlgoSource_Voice)
    {
        _InferComplete_Voice(dev, inferResult, currentScreenId);
    }

    return error;
}</codeblock>
                </body>
            </topic>
        </topic>
        <topic id="rgbled-output-hal-device">
            <title>RgbLed output HAL device</title>
            <body>
                <p>This HAL device driver is located in
                    "framework/hal/output/hal_output_rgb_led.c".</p>
                <p>It flashes the RGB led with different pattern according to the
                        <codeph>HAL_OutputDev_RgbLed_InferComplete</codeph> or
                        <codeph>HAL_OutputDev_RgbLed_InputNotify</codeph> operators below:</p>
                <codeblock xml:space="preserve" outputclass="c">static hal_output_status_t HAL_OutputDev_RgbLed_InferComplete(const output_dev_t *dev, output_algo_source_t source, void *inferResult)
{
    hal_output_status_t error = kStatus_HAL_OutputSuccess;
    uint32_t timerOn          = 0;
    _SetLedColor(APP_OutputDev_RgbLed_InferCompleteDecode(source, inferResult, &amp;timerOn));

    if (timerOn != 0)
    {
        xTimerChangePeriod(OutputRgbTimer, pdMS_TO_TICKS(timerOn), 0);
    }
    return error;
}</codeblock>
                <codeblock xml:space="preserve" outputclass="c">static hal_output_status_t HAL_OutputDev_RgbLed_InputNotify(const output_dev_t *dev, void *data)
{
    hal_output_status_t error = kStatus_HAL_OutputSuccess;

    _SetLedColor(APP_OutputDev_RgbLed_InputNotifyDecode(data));

    return error;
}</codeblock>
            </body>
        </topic>
        <topic id="messagebuffer-multicore-hal-device">
            <title>MessageBuffer multicore HAL device</title>
            <body>
                <p>This HAL device driver is located in
                    "framework/hal/misc/hal_multicore_messageBuffer.c".</p>
                <p>It handles the multicore messaging based on the multicore manager message buffer
                    mechanism.</p>
                <p>Refer the "framework/docs/hal_devices/multicore.md" file in the framework
                    documentation for the detailed description of this HAL device.</p>
            </body>
        </topic>
        <topic id="shellusb-input-hal-device">
            <title>ShellUsb input HAL device</title>
            <body>
                <p>This HAL device driver is located in
                    "framework/hal/input/hal_input_shell_cdc.c".</p>
                <p>It populates one USB CDC device and generates the shell.</p>
                <p>This driver only includes one <codeph>weak</codeph> shell command registration
                    function as below:</p>
                <codeblock xml:space="preserve" outputclass="c">__attribute__((weak)) void APP_InputDev_Shell_RegisterShellCommands(shell_handle_t shellContextHandle,  input_dev_t shellDev, input_dev_callback_t callback)
{
}</codeblock>
                <p>The application must overwrite this function to register the exactly shell
                    commands.</p>
                <p>The implementation of this overwritten function for the <codeph>Coffee
                        Machine</codeph> application is in
                    "coffee_machine/cm4/source/event_handler/smart_tlhmi_input_shell_commands.c":</p>
                <codeblock xml:space="preserve" outputclass="c">void APP_InputDev_Shell_RegisterShellCommands(shell_handle_t shellContextHandle, input_dev_t *shellDev, input_dev_callback_t callback)
{
    s_InputCallback            = callback;
    s_SourceShell              = shellDev;
    s_ShellHandle              = shellContextHandle;
    s_FrameworkRequest.respond = _FrameworkEventsHandler;

    if (s_ThingName == NULL)
    {
        APP_GetHexUniqueID(&amp;s_ThingName);
    }

    SHELL_RegisterCommand(shellContextHandle, SHELL_COMMAND(version));
    ...
}</codeblock>
            </body>
        </topic>
        <topic id="standby-lpm-hal-device">
            <title>Standby LPM HAL device</title>
            <body>
                <p>This HAL device driver is located in "framework/hal/misc/hal_lpm_standby.c".</p>
                <p>Refer to "framework/docs/hal_devices/low_power.md" in the framework documentation
                    for the detailed description of this LPM device.</p>
                <p>This standby HAL device implements the standby mode of this application. The
                    backlight is turned off and the main display layer is disabled.</p>
                <codeblock xml:space="preserve" outputclass="c">static void _EnterStandbyMode(void)
{
    LOGD("[Standby] Enter standby mode");
    BOARD_BacklightControl(0);
    lv_enable_ui_preview(0);
}</codeblock>
            </body>
        </topic>
    </topic>
    <topic id="logging">
        <title>Logging</title>
        <prolog>
            <data name="sidebar_position" value="3"/>
        </prolog>
        <body>
            <p>Both the CM7 and CM4 projects are leveraging the <xref
                    href="https://www.freertos.org/logging.html" format="html" scope="external"
                    >FreeRTOS logging library</xref>.</p>
            <p>The FreeRTOS logging library code is located in the logging folder where you can find
                the detailed document "coffee_machine/cm7/freertos/libraries/logging/README.md".</p>
            <p>The CM7 and CM4 share low-level LPUART12 peripheral for the logging output. The
                hardware semaphore mechanism is used to guarantee the concurrence access of the
                LPUART12 peripheral.</p>
            <p>They share a low-level timer to get the unified timestamp of the logging
                information.</p>
        </body>
        <topic id="logging-task-init">
            <title>Logging Task Init</title>
            <body>
                <p>Application calls <codeph>xLoggingTaskInitialize(...)</codeph> API to create the
                    logging task in the <codeph>main()</codeph> entry of this project is located in
                    the "coffee_machine/cm4/source/sln_smart_tlhmi_cm4.cpp" file:</p>
                <codeblock xml:space="preserve" outputclass="c">xLoggingTaskInitialize(LOGGING_TASK_STACK_SIZE, LOGGING_TASK_PRIORITY, LOGGING_QUEUE_LENGTH);</codeblock>
            </body>
        </topic>
        <topic id="logging-macros">
            <title>Logging Macros</title>
            <body>
                <p>The logging Macros are defined in "framework/inc/fwk_log.h".</p>
                <p>All the modules must use these unified logging Macros for logging.</p>
                <codeblock xml:space="preserve" outputclass="c">#ifndef LOGV
#define LOGV(fmt, args...) {implement...}
...
#endif

#ifndef LOGD
#define LOGD(fmt, args...) {implement...}
#endif

#ifndef LOGI
#define LOGI(fmt, args...) {implement...}
#endif

#ifndef LOGE
#define LOGE(fmt, args...) {implement...}
#endif</codeblock>
            </body>
        </topic>
    </topic>
</dita>
