<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE dita PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<dita>
    <topic id="elevator-cm4">
        <title>Elevator CM4</title>
        <body>
            <p>This Elevator CM4 slave project runs on the CM4 core.</p>
            <p>It is linked to SDRAM and will be embedded into the CM7 project.</p>
            <p>The CM7 project handles the loading of this CM4 project into SDRAM and launching of
                it.</p>
        </body>
    </topic>
    <topic id="main-functionalities">
        <title>Main functionalities</title>
        <body>
            <ul>
                <li><p>Main GUI based on LVGL with Vglite graphics acceleration</p></li>
                <li><p>Camera with 2D PxP graphics acceleration</p></li>
                <li><p>Display for the camera preview and LVGL GUI</p></li>
                <li><p>USB shell</p></li>
                <li><p>LED indicator</p></li>
                <li><p>Multicore with messaging and shared memory communication</p></li>
            </ul>
        </body>
    </topic>
    <topic id="lvgl-gui-screens-and-widgets">
        <title>LVGL GUI screens and widgets</title>
        <body>
            <p>All the LVGL GUI screens and widgets are generated with NXP's GUI Guider tools.</p>
            <p>Refer to the <xref
                    href="https://www.nxp.com/design/software/development-software/gui-guider:GUI-GUIDER"
                    format="html" scope="external">GUI Guider home page</xref> for more detailed
                information.</p>
        </body>
    </topic>
    <topic id="lvgl-and-vglite-library">
        <title>LVGL and Vglite library</title>
        <body>
            <p>LVGL and Vglite components are directly ported from RT1170 SDK where we did not
                modify them in our solution.</p>
            <p>The code for LVGL GUI screens and widgets, which are generated by NXP's GUI guider,
                is not frequently changed.</p>
            <p>To speed up the building of the whole project, we moved these components into one
                static library and linked the library to the CM4 application project.</p>
            <p>This LVGL and Vglite library project is located in the `../elevator/lvgl_vglite_lib` folder.</p>
        </body>
    </topic>
    <topic id="boot-sequence">
        <title>Boot sequence</title>
        <body>
            <p>Below is the core boot-up flow:</p>
            <ul>
                <li><p>Board level initialization</p></li>
                <li><p>Framework initialization</p></li>
                <li><p>HAL devices registration</p></li>
                <li><p>Framework startup</p></li>
                <li><p>FreeRTOS scheduler startup</p></li>
            </ul>
            <p>The <codeph>main()</codeph> entry of this project is located in the `../elevator/cm4/source/sln_smart_tlhmi_cm4.cpp` file:</p>
            <codeblock xml:space="preserve" outputclass="c">int main(void)
{
    /* init the board */
    APP_BoardInit();
    ...
    /* init the framework*/
    APP_InitFramework();

    /* register the hal devices*/
    APP_RegisterHalDevices();

    /* start the framework*/
    APP_StartFramework();

    vTaskStartScheduler();
    for (;;)
    {
    } /* should never get here */
    return 0;
}</codeblock>
        </body>
    </topic>
    <topic id="board-level-initialization">
        <title>Board level initialization</title>
        <body>
            <p>The board level initialization is implemented in the <codeph>APP_BoardInit()</codeph>
                entry which is located in the `../elevator/cm4/source/sln_smart_tlhmi_cm4.cpp` file.</p>
            <p>Below is the main flow:</p>
            <ul>
                <li><p>MPU, Clock, and Pins configuration</p></li>
                <li><p>Multicore manager init and slave startup</p></li>
                <li><p>Peripherals initialization</p></li>
            </ul>
            <codeblock xml:space="preserve" outputclass="c">void APP_BoardInit()
{
    BOARD_ConfigMPU();
    BOARD_BootClockRUN();
    BOARD_InitBootPins();

#if defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE
    uint32_t startupData, i;
    mcmgr_status_t status;
    (void)MCMGR_Init();
    /* Get the startup data */
    do
    {
        status = MCMGR_GetStartupData(&amp;startupData);
    } while (status != kStatus_MCMGR_Success);
#endif /* defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE */
    ...
    BOARD_MIPIPanelTouch_I2C_Init();
    BOARD_InitEDMA();
    Time_Init(1);
}</codeblock>
        </body>
    </topic>
    <topic id="lvgl-image-resource-loading">
        <title>LVGL image resource loading</title>
        <body>
            <p>All the LVGL images, data, and icon data are merged into one continuous binary block
                with the 64 Bytes aligned of each image/icon.</p>
            <p>The cm7 loads this resource binary block into the dedicated memory region
                    <codeph>res_sh_mem</codeph>.</p>
            <p>The below two function loads each of these LVGL images and icons from this region
                during the boot.</p>
            <p>Setup the LVGL images is implemented in `../elevator/cm4/generated/gui_guider.c":</p>
            <codeblock xml:space="preserve" outputclass="c">void setup_imgs(void *base)
{
    _TLHMI_Elevator_Main_Screen_1280x720.data                  = (base + 0);
    _TLHMI_Elevator_Virtual_Face_Blue_180x180.data             = (base + 2764800);
    _TLHMI_Elevator_Button_Call_alpha_90x90.data               = (base + 2862016);
    ....
}</codeblock>
        </body>
    </topic>
    <topic id="framework-managers">
        <title>Framework managers</title>
        <body>
            <p>The below framework managers are enabled on the cm4 side:</p>
            <ul>
                <li><p>Low-power manager</p></li>
                <li><p>Camera manager</p></li>
                <li><p>Display manager</p></li>
                <li><p>Multicore manager</p></li>
                <li><p>Output manager</p></li>
                <li><p>Input manager</p></li>
            </ul>
            <p>Refer to `/framework/docs/introduction.md` for a more detailed description of these framework managers.</p>
            <p>Framework initialization (`../elevator/cm4/source/sln_smart_tlhmi_cm4.cpp`):</p>
            <codeblock xml:space="preserve" outputclass="c">int APP_InitFramework(void)
{
    int ret = 0;

    FWK_MANAGER_INIT(LpmManager, ret);
    FWK_MANAGER_INIT(CameraManager, ret);
    FWK_MANAGER_INIT(DisplayManager, ret);
#if defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE
    FWK_MANAGER_INIT(MulticoreManager, ret);
#endif /* defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE */
    FWK_MANAGER_INIT(OutputManager, ret);
    FWK_MANAGER_INIT(InputManager, ret);

    return ret;
}</codeblock>
            <p>Framework startup (`../elevator/cm4/source/sln_smart_tlhmi_cm4.cpp`):></p>
            <codeblock xml:space="preserve" outputclass="c">int APP_StartFramework(void)
{
    int ret = 0;

    FWK_MANAGER_START(LpmManager, 0, ret);
    FWK_MANAGER_START(CameraManager, CAMERA_MANAGER_TASK_PRIORITY, ret);
    FWK_MANAGER_START(DisplayManager, DISPLAY_MANAGER_TASK_PRIORITY, ret);
#if defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE
    FWK_MANAGER_START(MulticoreManager, MULTICORE_MANAGER_TASK_PRIORITY, ret);
#endif /* defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE */
    FWK_MANAGER_START(OutputManager, OUTPUT_MANAGER_TASK_PRIORITY, ret);
    FWK_MANAGER_START(InputManager, INPUT_MANAGER_TASK_PRIORITY, ret);

    return ret;
}</codeblock>
        </body>
    </topic>
    <topic id="framework-hal-devices">
        <title>Framework HAL devices</title>
        <body>
            <p>The enabled HAL devices are configured in `../elevator/cm4/board/board_define.h` file as below:</p>
            <codeblock xml:space="preserve" outputclass="c">#define ENABLE_GFX_DEV_Pxp
#define ENABLE_DISPLAY_DEV_LVGLElevator
#define ENABLE_CAMERA_DEV_MipiGc2145
#define ENABLE_OUTPUT_DEV_RgbLed
#if defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE
#define ENABLE_MULTICORE_DEV_MessageBuffer
#endif /* defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE */
#define ENABLE_INPUT_DEV_ShellUsb
#define ENABLE_OUTPUT_DEV_UiElevator
#define ENABLE_LPM_DEV_Standby
</codeblock>
            <p>The registration of the enabled HAL devices is implemented in the
                    <codeph>APP_RegisterHalDevices(...)</codeph> function which is located in `../elevator/cm4/source/sln_smart_tlhmi_cm4.cpp`
            </p>
            <codeblock xml:space="preserve">The `APP_RegisterHalDevices(...)` must be called after the framework initialization `APP_InitFramework(...)` and before framework startup `APP_StartFramework(...)`.</codeblock>
            <codeblock xml:space="preserve" outputclass="c">int APP_RegisterHalDevices(void)
{
    int ret = 0;

    HAL_GFX_DEV_REGISTER(Pxp, ret);
    HAL_DISPLAY_DEV_REGISTER(LVGLElevator, ret);
    HAL_CAMERA_DEV_REGISTER(MipiGc2145, ret);
#if defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE
    HAL_MULTICORE_DEV_REGISTER(MessageBuffer, ret);
#endif /* defined(ENABLE_SLAVE) &amp;&amp; ENABLE_SLAVE */
    HAL_OUTPUT_DEV_REGISTER(RgbLed, ret);
    HAL_INPUT_DEV_REGISTER(ShellUsb, ret);
    HAL_OUTPUT_DEV_REGISTER(UiElevator, ret);
    HAL_LPM_DEV_REGISTER(Standby, ret);
    /* Add new HAL device registrations here */

    return ret;
}</codeblock>
        </body>
        <topic id="mipigc2145-camera-hal-device">
            <title>MipiGc2145 camera HAL device</title>
            <body>
                <p>This HAL device driver is located in `../framework/hal/camera/hal_camera_mipi_gc2145.c`.</p>
                <p>Below is the configuration of this camera device, which is located in `../elevator/cm4/board/board_define.h`.</p>
                <codeblock xml:space="preserve" outputclass="c">#ifdef ENABLE_CAMERA_DEV_MipiGc2145
#define CAMERA_DEV_MipiGc2145_BUFFER_COUNT 2
#define CAMERA_DEV_MipiGc2145_HEIGHT       600 // 720
#define CAMERA_DEV_MipiGc2145_WIDTH        800 // 1280
#define CAMERA_DEV_MipiGc2145_LEFT         0
#define CAMERA_DEV_MipiGc2145_TOP          0
#define CAMERA_DEV_MipiGc2145_RIGHT        799 // 1279
#define CAMERA_DEV_MipiGc2145_BOTTOM       599 // 719
#define CAMERA_DEV_MipiGc2145_ROTATE       kCWRotateDegree_0
#define CAMERA_DEV_MipiGc2145_FLIP         kFlipMode_None
#define CAMERA_DEV_MipiGc2145_SWAPBYTE     0
#define CAMERA_DEV_MipiGc2145_FORMAT       kPixelFormat_YUV1P444_RGB
#define CAMERA_DEV_MipiGc2145_BPP          4
#endif /* ENABLE_CAMERA_DEV_MipiGc2145 */</codeblock>
            </body>
        </topic>
        <topic id="pxp-graphics-hal-device">
            <title>PxP graphics HAL device</title>
            <body>
                <p>This HAL device driver is located in `../framework/hal/misc/hal_graphics_pxp.c`.</p>
                <p>It represents the 2D graphics device to handle the 2D graphics operations.</p>
            </body>
        </topic>
        <topic id="lvglelevator-display-hal-device">
            <title>LVGLElevator display HAL device</title>
            <body>
                <p>This HAL device driver is located in `../framework/hal/display/hal_display_lvgl_elevator.c`.</p>
                <p>Below is the configuration of this display device which is located in `../elevator/cm4/board/board_define.h`.</p>
                <codeblock xml:space="preserve" outputclass="c">#ifdef ENABLE_DISPLAY_DEV_LVGLElevator
#define DISPLAY_DEV_LVGLElevator_BUFFER_COUNT 1
#define DISPLAY_DEV_LVGLElevator_HEIGHT       640
#define DISPLAY_DEV_LVGLElevator_WIDTH        480
#define DISPLAY_DEV_LVGLElevator_StartX       80
#define DISPLAY_DEV_LVGLElevator_StartY       50
#define DISPLAY_DEV_LVGLElevator_LEFT         0
#define DISPLAY_DEV_LVGLElevator_TOP          0
#define DISPLAY_DEV_LVGLElevator_RIGHT        479
#define DISPLAY_DEV_LVGLElevator_BOTTOM       639
#define DISPLAY_DEV_LVGLElevator_ROTATE       kCWRotateDegree_270
#define DISPLAY_DEV_LVGLElevator_FORMAT       kPixelFormat_RGB565
#ifdef ENABLE_CAMERA_DEV_MipiGc2145
#define DISPLAY_DEV_LVGLElevator_SRCFORMAT kPixelFormat_YUV1P444_RGB
#else
#define DISPLAY_DEV_LVGLElevator_SRCFORMAT kPixelFormat_UYVY1P422_RGB
#endif
#define DISPLAY_DEV_LVGLElevator_BPP 2
#endif /* ENABLE_DisplayDev_LVGLElevator */</codeblock>
                <p>This LVGLElevator display HAL device launches the main LVGL task loop for the UI
                    flashing.</p>
                <codeblock xml:space="preserve" outputclass="c">static void _LvglTask(void *param)
{
#if LV_USE_LOG
    lv_log_register_print_cb(_PrintCb);
#endif /* LV_USE_LOG */

    lv_port_pre_init();
    lv_init();
    lv_port_disp_init();
    lv_port_indev_init();
    g_LvglInitialized = true;

    setup_imgs((unsigned char *)APP_LVGL_IMGS_BASE);
    setup_ui(&amp;guider_ui);
    events_init(&amp;guider_ui);
    custom_init(&amp;guider_ui);
    while (1)
    {
        lv_task_handler();
        vTaskDelay(pdMS_TO_TICKS(5));
    }
}</codeblock>
            </body>
        </topic>
        <topic id="uielevator-ui-output-hal-device">
            <title>UiElevator UI output HAL device</title>
            <body>
                <p>This HAL device driver is located in `../framework/hal/output/hal_output_ui_elevator.c`.</p>
                <p>The whole UI state machine is driven by this output HAL device with the below
                    event sources:</p>
            </body>
            <topic id="lvgl-touch-events">
                <title>LVGL touch events</title>
                <body>
                    <p>All the event callbacks of the LVGL widget are implemented in `../elevator/cm4/generated/events_init.c`.</p>
                </body>
            </topic>
            <topic id="vision-and-voice-algorithm-inference-result">
                <title>Vision and Voice algorithm inference result</title>
                <body>
                    <p>The vision and voice inference result is notified by the output manager with
                        below <codeph>HAL_OutputDev_UiElevator_InferComplete</codeph> operator:</p>
                    <codeblock xml:space="preserve" outputclass="c">static hal_output_status_t HAL_OutputDev_UiElevator_InferComplete(const output_dev_t *dev,output_algo_source_t source,void *inferResult)
{
    hal_output_status_t error = kStatus_HAL_OutputSuccess;

    if (inferResult == NULL)
    {
        return error;
    }

    if (source == kOutputAlgoSource_Vision)
    {
        _InferComplete_Vision(dev, inferResult);
    }
    else if (source == kOutputAlgoSource_Voice)
    {
        _InferComplete_Voice(dev, inferResult);
    }

    return error;
}</codeblock>
                </body>
            </topic>
        </topic>
        <topic id="rgbled-output-hal-device">
            <title>RgbLed output HAL device</title>
            <body>
                <p>This HAL device driver is located in `../framework/hal/output/hal_output_rgb_led.c`.</p>
                <p>It flashes the RGB led with different pattern according to the
                        <codeph>HAL_OutputDev_RgbLed_InferComplete</codeph> or
                        <codeph>HAL_OutputDev_RgbLed_InputNotify</codeph> operators below:</p>
                <codeblock xml:space="preserve" outputclass="c">static hal_output_status_t HAL_OutputDev_RgbLed_InferComplete(const output_dev_t *dev, output_algo_source_t source, void *inferResult)
{
    hal_output_status_t error = kStatus_HAL_OutputSuccess;
    uint32_t timerOn          = 0;
    _SetLedColor(APP_OutputDev_RgbLed_InferCompleteDecode(source, inferResult, &amp;timerOn));

    if (timerOn != 0)
    {
        xTimerChangePeriod(OutputRgbTimer, pdMS_TO_TICKS(timerOn), 0);
    }
    return error;
}</codeblock>
                <codeblock xml:space="preserve" outputclass="c">static hal_output_status_t HAL_OutputDev_RgbLed_InputNotify(const output_dev_t *dev, void *data)
{
    hal_output_status_t error = kStatus_HAL_OutputSuccess;

    _SetLedColor(APP_OutputDev_RgbLed_InputNotifyDecode(data));

    return error;
}</codeblock>
            </body>
        </topic>
        <topic id="messagebuffer-multicore-hal-device">
            <title>MessageBuffer multicore HAL device</title>
            <body>
                <p>This HAL device driver is located in `../framework/hal/misc/hal_multicore_messageBuffer.c`.</p>
                <p>It handles the multicore messaging based on the multicore manager message buffer
                    mechanism.</p>
                <p>For the detailed description of this HAL device, refer to `../framework/docs/hal_devices/multicore.md` in the framework documentation.</p>
            </body>
        </topic>
        <topic id="shellusb-input-hal-device">
            <title>ShellUsb input HAL device</title>
            <body>
                <p>This HAL device driver is located in `../framework/hal/input/hal_input_shell_cdc.c`.</p>
                <p>It populates one USB CDC device and generates the shell.</p>
                <p>This driver only includes one <codeph>weak</codeph> shell command registration
                    function as below:</p>
                <codeblock xml:space="preserve" outputclass="c">__attribute__((weak)) void APP_InputDev_Shell_RegisterShellCommands(shell_handle_t shellContextHandle,  input_dev_t shellDev, input_dev_callback_t callback)
{
}</codeblock>
                <p>The application must overwrite this function to register the exactly shell
                    commands.</p>
                <p>You can find the implementation of this overwritten function for the
                        <codeph>Elevator</codeph> application from `../elevator/cm4/source/event_handlers/smart_tlhmi_input_shell_commands.c`:</p>
                <codeblock xml:space="preserve" outputclass="c">void APP_InputDev_Shell_RegisterShellCommands(shell_handle_t shellContextHandle, input_dev_t *shellDev, input_dev_callback_t callback)
{
    s_InputCallback            = callback;
    s_SourceShell              = shellDev;
    s_ShellHandle              = shellContextHandle;
    s_FrameworkRequest.respond = _FrameworkEventsHandler;

    if (s_ThingName == NULL)
    {
        APP_GetHexUniqueID(&amp;s_ThingName);
    }

    SHELL_RegisterCommand(shellContextHandle, SHELL_COMMAND(version));
    ...
}</codeblock>
            </body>
        </topic>
        <topic id="standby-lpm-hal-device">
            <title>Standby LPM HAL device</title>
            <body>
                <p>This HAL device driver is located in `../framework/hal/misc/hal_lpm_standby.c`.</p>
                <p>For the detailed description of this LPM device refer to `../framework/docs/hal_devices/low_power.md` in the framework documentation.</p>
                <p>This standby HAL device implements the standby mode of this application. The
                    backlight is turned off and the main display layer is disabled.</p>
                <codeblock xml:space="preserve" outputclass="c">static void _EnterStandbyMode(void)
{
    LOGD("[Standby] Enter standby mode");
    BOARD_BacklightControl(0);
    lv_enable_ui_preview(0);
}</codeblock>
            </body>
        </topic>
    </topic>
    <topic id="logging">
        <title>Logging</title>
        <body>
            <p>Both the CM7 and CM4 projects are leveraging the <xref
                    href="https://www.freertos.org/logging.html" format="html" scope="external"
                    >FreeRTOS logging library</xref>.</p>
            <p>The FreeRTOS logging library code is located in the logging folder where you can find
                the detailed document `../coffee_machine/cm4/freertos/libraries/logging/README.md`.</p>
            <p>The CM7 and CM4 share low-level LPUART12 peripheral for the logging output. The
                hardware semaphore mechanism is used to guarantee the concurrence access of LPUART12
                peripheral.</p>
            <p>They share a low-level timer to get the unified timestamp of the logging
                information.</p>
        </body>
        <topic id="logging-task-init">
            <title>Logging task init</title>
            <body>
                <p>Application calls <codeph>xLoggingTaskInitialize(...)</codeph> API to create the
                    logging task in the <codeph>main()</codeph> entry of this project is located in
                    the `../coffee_machine/cm4/source/sln_smart_tlhmi_cm4.cpp`:</p>
                <codeblock xml:space="preserve" outputclass="c">xLoggingTaskInitialize(LOGGING_TASK_STACK_SIZE, LOGGING_TASK_PRIORITY, LOGGING_QUEUE_LENGTH);</codeblock>
            </body>
        </topic>
        <topic id="logging-macros">
            <title>Logging macros</title>
            <body>
                <p>The logging Macros are defined in `../framework/inc/fwk_log.h`.</p>
                <p>All the modules must use these unified logging Macros for logging.</p>
                <codeblock xml:space="preserve" outputclass="c">#ifndef LOGV
#define LOGV(fmt, args...) {implement...}
...
#endif

#ifndef LOGD
#define LOGD(fmt, args...) {implement...}
#endif

#ifndef LOGI
#define LOGI(fmt, args...) {implement...}
#endif

#ifndef LOGE
#define LOGE(fmt, args...) {implement...}
#endif</codeblock>
            </body>
        </topic>
    </topic>
</dita>
